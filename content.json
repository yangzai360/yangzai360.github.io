{"meta":{"title":"扬仔的技术博客","subtitle":"","description":"","author":"yangzai360","url":"http://yangzai360.top","root":"/"},"pages":[],"posts":[{"title":"OC Runtime 大手稿：四、类布局过程","slug":"OCBigManuscript04_ClassLayout","date":"2020-11-01T03:35:19.688Z","updated":"2020-11-01T03:36:42.691Z","comments":true,"path":"2020/11/01/OCBigManuscript04_ClassLayout/","link":"","permalink":"http://yangzai360.top/2020/11/01/OCBigManuscript04_ClassLayout/","excerpt":"","text":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 第三篇：类布局过程 在执行到 main 之前，","categories":[],"tags":[]},{"title":"OC Runtime 大手稿：三、对象销毁流程","slug":"OCBigManuscript03_ObjectDealloc","date":"2020-10-31T13:57:15.140Z","updated":"2020-11-01T01:51:54.562Z","comments":true,"path":"2020/10/31/OCBigManuscript03_ObjectDealloc/","link":"","permalink":"http://yangzai360.top/2020/10/31/OCBigManuscript03_ObjectDealloc/","excerpt":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 第三篇：对象销毁流程 未完成!NFY Not finished yet. 基本的流程已经梳理完了，图显得有些突兀，主要是因为右上角的那个方法中有很多官方的注释，以及我没有对其进行拆解和简化。 这里面有一些知识点没有特别细致的展开，例如： sidetable 结构和应用操作的整理汇总 weak 散列表的操作展开讲 最后一些流程用到的方法查找函数是仅仅提供给查找 构造函数 和 析构函数 使用的","text":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 第三篇：对象销毁流程 未完成!NFY Not finished yet. 基本的流程已经梳理完了，图显得有些突兀，主要是因为右上角的那个方法中有很多官方的注释，以及我没有对其进行拆解和简化。 这里面有一些知识点没有特别细致的展开，例如： sidetable 结构和应用操作的整理汇总 weak 散列表的操作展开讲 最后一些流程用到的方法查找函数是仅仅提供给查找 构造函数 和 析构函数 使用的 1References OC 看objc源码认识retain、release、dealloc。第一个断点出现之前有一大堆retain release 和 side table 的操作，看不太懂，看了这篇文档 Objective-C Runtime 中内存释放的并发问题感谢译者 @一只羊的北京，找这个 static int _collecting_in_critical(void)，有点点不理解的地方，讲的很透彻，全网中文资料独此一篇 http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/iOS进阶——iOS（Objective-C）内存管理·二","categories":[],"tags":[]},{"title":"常用 Runtime 操作整理","slug":"CWC02_CEOOCRuntimeInAction_CookActuallyUsedInCooking","date":"2020-10-31T09:40:39.350Z","updated":"2020-11-01T09:59:06.018Z","comments":true,"path":"2020/10/31/CWC02_CEOOCRuntimeInAction_CookActuallyUsedInCooking/","link":"","permalink":"http://yangzai360.top/2020/10/31/CWC02_CEOOCRuntimeInAction_CookActuallyUsedInCooking/","excerpt":"本篇英文名叫 OC Runtime In Action：CEO Cook Actually Used In Cooking，翻译过来的意思是开发人员实际开发的时候使用的 runtime 操作。进行积累整理。","text":"本篇英文名叫 OC Runtime In Action：CEO Cook Actually Used In Cooking，翻译过来的意思是开发人员实际开发的时候使用的 runtime 操作。进行积累整理。 隶属于我的第二个大系列 CWC ：Cooking With Cook，翻译过来的中文意思就是 作为一个长期热爱苹果的苹果开发者，陪着水果公司一起积累和成长。 1. 接触 Runtime 的方式正常开发的时候，我们通过三个渠道来接触到runtime OC 层面, eg： @selector Runtime API， eg: objc-getclass() 这些方法，msgSend()，setassosiciatedObject()等 NSObject 相关的 API, eg: 2. 在lldb中打印 objc_class isa 的指向类这点虽然不是调用runtime，但是涉及到了isa指针的相关知识。 直接通过位运算与上掩码来取类指针 这里与操作后面的值就是 ISAMASK，根据操作平台不同。 3. 通过 @encode 打印所有的type encodingshttps://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100 这个还是有用的，因为其实 method_t 里面满共就三四个值，一个name，一个imp实现指针，一个就是方法的 TypeEncodings 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - 各种类型编码void logAllTypeCodings() &#123; NSLog(@&quot;char --&gt; %s&quot;,@encode(char)); NSLog(@&quot;int --&gt; %s&quot;,@encode(int)); NSLog(@&quot;short --&gt; %s&quot;,@encode(short)); NSLog(@&quot;long --&gt; %s&quot;,@encode(long)); NSLog(@&quot;long long --&gt; %s&quot;,@encode(long long)); NSLog(@&quot;unsigned char --&gt; %s&quot;,@encode(unsigned char)); NSLog(@&quot;unsigned int --&gt; %s&quot;,@encode(unsigned int)); NSLog(@&quot;unsigned short --&gt; %s&quot;,@encode(unsigned short)); NSLog(@&quot;unsigned long --&gt; %s&quot;,@encode(unsigned long long)); NSLog(@&quot;float --&gt; %s&quot;,@encode(float)); NSLog(@&quot;bool --&gt; %s&quot;,@encode(bool)); NSLog(@&quot;void --&gt; %s&quot;,@encode(void)); NSLog(@&quot;char * --&gt; %s&quot;,@encode(char *)); NSLog(@&quot;id --&gt; %s&quot;,@encode(id)); NSLog(@&quot;Class --&gt; %s&quot;,@encode(Class)); NSLog(@&quot;SEL --&gt; %s&quot;,@encode(SEL)); int array[] = &#123;1,2,3&#125;; NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(array))); typedef struct person&#123; char *name; int age; &#125;Person; NSLog(@&quot;struct --&gt; %s&quot;,@encode(Person)); typedef union union_type&#123; char *name; int a; &#125;Union; NSLog(@&quot;union --&gt; %s&quot;,@encode(Union)); int a = 2; int *b = &#123;&amp;a&#125;; NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(b)));&#125; 12345678910111213141516171819202020-11-01 15:21:03.434385+0800 001-类的属性与变量[34325:1798027] char --&gt; c2020-11-01 15:21:03.434742+0800 001-类的属性与变量[34325:1798027] int --&gt; i2020-11-01 15:21:03.434775+0800 001-类的属性与变量[34325:1798027] short --&gt; s2020-11-01 15:21:03.434796+0800 001-类的属性与变量[34325:1798027] long --&gt; q2020-11-01 15:21:03.434815+0800 001-类的属性与变量[34325:1798027] long long --&gt; q2020-11-01 15:21:03.434834+0800 001-类的属性与变量[34325:1798027] unsigned char --&gt; C2020-11-01 15:21:03.434855+0800 001-类的属性与变量[34325:1798027] unsigned int --&gt; I2020-11-01 15:21:03.434873+0800 001-类的属性与变量[34325:1798027] unsigned short --&gt; S2020-11-01 15:21:03.434891+0800 001-类的属性与变量[34325:1798027] unsigned long --&gt; Q2020-11-01 15:21:03.434910+0800 001-类的属性与变量[34325:1798027] float --&gt; f2020-11-01 15:21:03.434957+0800 001-类的属性与变量[34325:1798027] bool --&gt; B2020-11-01 15:21:03.434998+0800 001-类的属性与变量[34325:1798027] void --&gt; v2020-11-01 15:21:03.435051+0800 001-类的属性与变量[34325:1798027] char * --&gt; *2020-11-01 15:21:03.733132+0800 001-类的属性与变量[34325:1798027] id --&gt; @2020-11-01 15:21:03.733181+0800 001-类的属性与变量[34325:1798027] Class --&gt; #2020-11-01 15:21:03.733214+0800 001-类的属性与变量[34325:1798027] SEL --&gt; :2020-11-01 15:21:03.733242+0800 001-类的属性与变量[34325:1798027] int[] --&gt; [3i]2020-11-01 15:21:03.733270+0800 001-类的属性与变量[34325:1798027] struct --&gt; &#123;person=*i&#125;2020-11-01 15:21:03.733297+0800 001-类的属性与变量[34325:1798027] union --&gt; (union_type=*i)2020-11-01 15:21:03.733324+0800 001-类的属性与变量[34325:1798027] int[] --&gt; ^i 4. 打印所有的类的属性12345678910111213141516171819202122232425262728293031#import &lt;objc/runtime.h&gt;#ifdef DEBUG#define LGLog(format, ...) printf(&quot;%s\\n&quot;, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);#else#define LGLog(format, ...);#endifvoid getObjc_copyIvar_copyProperies(Class pClass)&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList(pClass, &amp;count); for (unsigned int i=0; i &lt; count; i++) &#123; Ivar const ivar = ivars[i]; //获取实例变量名 const char*cName = ivar_getName(ivar); NSString *ivarName = [NSString stringWithUTF8String:cName]; LGLog(@&quot;class_copyIvarList:%@&quot;,ivarName); &#125; free(ivars); unsigned int pCount = 0; objc_property_t *properties = class_copyPropertyList(pClass, &amp;pCount); for (unsigned int i=0; i &lt; pCount; i++) &#123; objc_property_t const property = properties[i]; //获取属性名 NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; //获取属性值 LGLog(@&quot;class_copyProperiesList:%@&quot;,propertyName); &#125; free(properties);&#125; #5. 查找 方法 不像上一点那么通用，需要手动查是否包含该方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#import &lt;objc/runtime.h&gt;#ifdef DEBUG#define getLog(format, ...) printf(&quot;%s\\n&quot;, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);#else#define getLog(format, ...);#endifvoid getObjc_copyMethodList(Class pClass) &#123; unsigned int count = 0; Method *methods = class_copyMethodList(pClass, &amp;count); for (unsigned int i=0; i &lt; count; i++) &#123; Method const method = methods[i]; //获取方法名 NSString *key = NSStringFromSelector(method_getName(method)); getLog(@&quot;Method, name: %@&quot;, key); &#125; free(methods);&#125;void getInstanceMethod_classToMetaclass(Class pClass) &#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); Method method1 = class_getInstanceMethod(pClass, @selector(sayHello)); Method method2 = class_getInstanceMethod(metaClass, @selector(sayHello)); Method method3 = class_getInstanceMethod(pClass, @selector(sayHappy)); Method method4 = class_getInstanceMethod(metaClass, @selector(sayHappy)); getLog(@&quot;%s - %p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);&#125;void getClassMethod_classToMetaclass(Class pClass) &#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); Method method1 = class_getClassMethod(pClass, @selector(sayHello)); Method method2 = class_getClassMethod(metaClass, @selector(sayHello)); Method method3 = class_getClassMethod(pClass, @selector(sayHappy)); // 元类 为什么有 sayHappy 类方法 0 1 // Method method4 = class_getClassMethod(metaClass, @selector(sayHappy)); getLog(@&quot;%s-%p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);&#125;void getIMP_classToMetaclass(Class pClass) &#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); // - (void)sayHello; // + (void)sayHappy; IMP imp1 = class_getMethodImplementation(pClass, @selector(sayHello)); IMP imp2 = class_getMethodImplementation(metaClass, @selector(sayHello)); IMP imp3 = class_getMethodImplementation(pClass, @selector(sayHappy)); IMP imp4 = class_getMethodImplementation(metaClass, @selector(sayHappy)); NSLog(@&quot;%p-%p-%p-%p&quot;,imp1,imp2,imp3,imp4); NSLog(@&quot;%s&quot;,__func__);&#125; 6. print all properties12345678910111213141516//- (void)printClassAllProperties:(Class)cls &#123;void printClassAllProperties(Class cls) &#123; unsigned int outCount = 0; objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount); NSMutableArray *propertiesAry = [NSMutableArray arrayWithCapacity:outCount]; for (int i = 0; i&lt;outCount; i++) &#123; // objc property t 属性 objc_property_t property = properties[i]; // 获取属性名称 C字符串 const char *cName = property_getName(property); // 转换成 OC 字符串 NSString *name = [NSString stringWithCString:cName encoding:NSUTF8StringEncoding]; [propertiesAry addObject:name]; NSLog(@&quot;属性： %@&quot;, name); &#125;&#125; 另外这里有一个另外的函数，读取property 的 attribute，property_getAttributes(property) 打印出来会比如这种：T@&quot;NSString&quot;,C,N,V_name","categories":[],"tags":[]},{"title":"从 LLVM 到 clang","slug":"From_LLVM_to_clang","date":"2020-10-31T06:32:48.421Z","updated":"2020-10-31T19:04:19.112Z","comments":true,"path":"2020/10/31/From_LLVM_to_clang/","link":"","permalink":"http://yangzai360.top/2020/10/31/From_LLVM_to_clang/","excerpt":"NFY NotFinishedYet：还没有写完。。。","text":"NFY NotFinishedYet：还没有写完。。。 本篇英文名叫 From LLVM To Clang: Cook Spend Money Buy A Big Kitchen，翻译过来的意思是从 LLVM 研究到 Clang 的一个简单了解和介绍，苹果在这个上面花了很多精力和时间的投入，所以值得我们好好研究。 隶属于我的第二个大系列：CookingWithCook，翻译过来的中文意思就是 作为一个长期热爱苹果的苹果开发者，跟随苹果公司一起积累和成长。 从 LLVM 到 clang 1.1 简介：开发故事英文全称：Low Level Virtual Machine LLVM 计划启动于2000年，最初由美国UIUC大学的 Chris Lattner 博士主持开展。 2006年Chris Lattner加盟Apple Inc. 并致力于 LLVM 在 Apple 开发体系中的应用。Apple 也是 LLVM 计划的主要资助者。 目前 LLVM 已经被Apple、Microsoft、Google、Facebook等各大公司采用。 Apple已经将它用在OpenCL的流水线优化，Xcode已经能使用llvm-gcc编译代码。 2011-12-02 LLVM3.0发布，LLVM包括了一系列子项目，它们也同步发布了新版本，如C/C++/Objective-C前端Clang 3.0改进了C++程序编译支持；改进C++ 2011标准支持；实现支持即将发布的C1x标准的某些特性；更快的生成代码，更快的编译，等等。 对于普通的开发人员来说，LLVM计划提供了越来越多的可以使用、编译器以外的其他工具。例如代码静态检查工具LLVM/Clang Static Analyzer，是一个 Clang 的子项目，能够使用同样的 Makefile 生成 HTML 格式的分析报告。 1.2 功能简介LLVM 核心库提供了与编译器相关的支持，可以作为多种语言编译器的后台来使用。能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。 LLVM是伊利诺伊大学的一个研究项目，提供一个现代化的，基于SSA的编译策略能够同时支持静态和动态的任意编程语言的编译目标。 LLVM 用 C++ 编写，用于优化任意编程语言编写的程序的编译过程，包括： 编译时间 链接时间 运行时间 空闲时间 LLVM的项目是一个模块化和可重复使用的编译器和工具技术的集合 我们常接触的LLVM，比如经常使用如下的命令去编译 main.c 123456789clang -rewrite-objc main.m -o main.cppclang -rewrite-objc -fobjc-arc -fobjc&#x3D;runtime&#x3D;ios-13.0.0 -istroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Plantforms&#x2F;iPhoneSimulator.plantform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator13.0.sdk main.m main.m -o main.cpp&#x2F;&#x2F;xcode 安装自带一个 xcrun 命令，其实xcrun 是继宇 clang 进行的封装，更好用一些xcrun -SDK iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp (模拟器)xcrun -SDK iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp (手机) Referencesllvm.org LLVM 入门篇作者说国内有关LLVM的东西太缺乏了 苹果官方简介文档 WWDC Session 关于 LLVM 的部分 https://www.oschina.net/p/llvm 系列会http://llvm-hpc2-workshop.github.io https://llvm.comptechs.cn/docs/如果您是仅对使用基于LLVM的编译器感兴趣的用户，则应该查看Clang文档：https://clang.llvm.org 短博客博客：LLVM编译原理和使用 博客：深入浅出让你理解什么是LLVM https://my.oschina.net/u/4360182/blog/3279626","categories":[],"tags":[]},{"title":"OC Runtime 大手稿：二、实例化源码流程","slug":"OCBigManuscript02_ObjectAllocInit","date":"2020-10-29T18:36:59.398Z","updated":"2020-11-01T00:38:41.449Z","comments":true,"path":"2020/10/30/OCBigManuscript02_ObjectAllocInit/","link":"","permalink":"http://yangzai360.top/2020/10/30/OCBigManuscript02_ObjectAllocInit/","excerpt":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 第二篇：实例化源码流程","text":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 第二篇：实例化源码流程 上图 这篇画图废了10多个小时时间，先不展开写了，后面有空再补上吧 Referenceshttps://www.jianshu.com/p/9d649ce6d0b8 https://blog.csdn.net/myiphon/article/details/105159233 https://github.com/draveness/analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md#深入解析-objc-中方法的结构 https://www.jianshu.com/p/9d649ce6d0b8 大感谢：霜神的这篇Objc 对象的今生今世 https://www.jianshu.com/p/f725d2828a2f","categories":[],"tags":[]},{"title":"Apple 源码用到的一些数据结构","slug":"CWC01_KitchenToolsThatCookLoves","date":"2020-10-28T10:00:23.399Z","updated":"2020-10-31T15:46:24.335Z","comments":true,"path":"2020/10/28/CWC01_KitchenToolsThatCookLoves/","link":"","permalink":"http://yangzai360.top/2020/10/28/CWC01_KitchenToolsThatCookLoves/","excerpt":"本篇英文名叫 Kitchen Tools That Cook Loves，翻译过来的意思是苹果源码中出现的一些数据结构，不断积累更新。 隶属于我的第二个大系列 CWC ：Cooking With Cook，翻译过来的中文意思就是 作为一个长期热爱苹果的苹果开发者，陪着水果公司一起积累和成长。 目前：entsize_list_tt、list_array_tt…","text":"本篇英文名叫 Kitchen Tools That Cook Loves，翻译过来的意思是苹果源码中出现的一些数据结构，不断积累更新。 隶属于我的第二个大系列 CWC ：Cooking With Cook，翻译过来的中文意思就是 作为一个长期热爱苹果的苹果开发者，陪着水果公司一起积累和成长。 目前：entsize_list_tt、list_array_tt… entsize_list_ttentsize_list_tt 其实就是一个通用的容器，可以获取 内部的迭代器，用于遍历内部存储的元素 Element: 元素的类型 List: 指定容器的具体实现类型 uint32_t flagmask: flagmask 标记位 出现场景： 类的 ro 中的 ivar_list_t 类的 ro rw rwe 中的 property_array_t 中的 property_list_t 类的 ro rw rwe 中的 method_array_t 中的 method_list_t 三者的声明头如下： 123struct ivar_list_t : entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt;struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt;struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, 0x3&gt; entsize_list_t 定义源码，省略大部分方法： 12345678910111213141516171819202122232425262728/************************************************************************ entsize_list_tt&lt;Element, List, FlagMask&gt;* 一系列非精致结构体的数组的实现** Element 元素是结构体类型 (e.g. method_t)* List 是这个结构体的特殊实现子类 (e.g. method_list_t)* FFlagMask 用于在 entsize 字段中存储额外的位* (e.g. method list fixup markers)**********************************************************************/template &lt;typename Element, typename List, uint32_t FlagMask&gt;struct entsize_list_tt &#123; uint32_t entsizeAndFlags; uint32_t count; Element first; struct iterator; struct iterator &#123; uint32_t entsize; uint32_t index; // keeping track of this saves a divide in operator- Element* element; typedef std::random_access_iterator_tag iterator_category; typedef Element value_type; typedef ptrdiff_t difference_type; typedef Element* pointer; typedef Element&amp; reference; &#125;&#125; list_array_tt这个类用来表示一个空、单数组、或者多数组。它和 list 的区别就是 多了一个多维数组的封装。 出现场景： 类的 rw rwe 中的 method_array_t 类的 rw rwe 中的 property_array_t 类的 rw rwe 中的 protocol_array_t ro 中没有，只有三个单 List。 三者的声明头如下： 12345678class method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; class property_array_t : public list_array_tt&lt;property_t, property_list_t&gt; class protocol_array_t : public list_array_tt&lt;protocol_ref_t, protocol_list_t&gt; list_array_tt 源码部分如下： 1234567891011121314151617181920212223242526272829/************************************************************************ list_array_tt&lt;Element, List&gt;* 元数据的通用实现，可以按类别进行扩展。** Element：基础元数据类型(e.g. method_t)* List： 元数据的列表类型(e.g. method_list_t)** list_array_tt具有以下三个值之一：* - 空* - 指向单个列表的指针* - 指向多个列表的指针的数组** countLists/beginLists/endLists 迭代元数据* count/begin/end 迭代基础元数据元素**********************************************************************/template &lt;typename Element, typename List&gt;class list_array_tt &#123; struct array_t &#123; uint32_t count; List* lists[0]; static size_t byteSize(uint32_t count) &#123; return sizeof(array_t) + count*sizeof(lists[0]); &#125; size_t byteSize() &#123; return byteSize(count); &#125; &#125;;&#125; 扩展扩展：non-fragile structs 是什么？OC 1.0 （iOS自始至终都是2.0起的，Mac最开始是1.0）译器生成了一个 ivar 布局，显示了在类中从哪可以访问ivars，对 ivar 的访问就可以通过 对象地址 ＋ ivar偏移字节 的方法。苹果更新了NSObject类，例如增加一些属性，这个又是静态库，发布新版本的系统，这个时候布局就出错了，就不得不重新编译子类来恢复兼容性。(那如果是在线上运行的app，升级系统后就没办法运行了) 使用 Non Fragile ivars 时，程序进行检测来调整类中新增的 ivar 的偏移量。 这样就可以通过 对象地址 ＋ 基类大小 + ivar偏移字节 的方法来计算出 ivar 相应的地址，并访问到相应的 ivar。(即使升级iOS系统，之前的app也能正常运行) 扩展再扩展：为什么OC类不能动态添加成员变量？runtime函数中，确实有一个class_addIvar()函数用于给类添加成员变量，但是文档中特别说明：This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported. 这个函数只能在“构建一个类的过程中”调用。一旦完成类定义，就不能再添加成员变量了。经过编译的类在程序启动后就被runtime加载，没有机会调用addIvar。程序在运行时动态构建的类需要在调用objc_registerClassPair之后才可以被使用，同样没有机会再添加成员变量。理论上说，我还是认为可以添加，只是为什么一定不可以，就不得而知了。 References objective-c non-fragile ivars 学习笔记 Non Fragile ivars","categories":[],"tags":[]},{"title":"OC Runtime 大手稿：一、整体数据结构","slug":"OCBigManuscript01_StructGlimpse","date":"2020-10-28T09:48:07.763Z","updated":"2020-11-01T01:42:33.739Z","comments":true,"path":"2020/10/28/OCBigManuscript01_StructGlimpse/","link":"","permalink":"http://yangzai360.top/2020/10/28/OCBigManuscript01_StructGlimpse/","excerpt":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 始篇，从对类对象使用的数据结构的静态关联分析开始。也就是从源码中找到他们的定义和关联关系。不做运行的分析等。","text":"复杂度高的项目系统，我惯于花时间梳理出大手稿，作为参考，根据这个思路，我花时间对于OC底层的机制进行梳理，产出大手稿若干。 始篇，从对类对象使用的数据结构的静态关联分析开始。也就是从源码中找到他们的定义和关联关系。不做运行的分析等。 思路想法： 整体数据结构 alloc init 实例化源码流程 dealloc 对象消亡源码流程 应用 main 之前：macho、imageload 流程 消息调用机制，方法查找流程 应用常见操作原理（例如super原理） 关联对象 &amp; methodSwi &amp; isaSwi Runtime 所有 API 汇总速查 IDE 上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释，这叫做 enable strict checking of objc_msgSend Calls 本篇，完成概要整体结构。不包括 classdatabitst 到 ro rw rwe 的演变以及后续过程。不包括 objc_class 中对于 cache 的处理（在方法查找流程里写）。 整体代码基于目前官方最近开源的OC底层源码版本objc4_781，主要研究 objc-runtime-new.h 文件，runtime 这部分包： OC 的声明后的实现部分开源。 底层调用的 C 和 C++ 开源。 汇编语言.mm，Apple 对于一部分CC++无法实现的功能使用，例如msgSend 整个逻辑关系图如下 1. objc_object 「万物之源」连类的结构都是基于 objc_object 的，所以说 OC 里面一切皆对象呢。 objc_object 1234/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 1.1 id 和 isaid 的本质其实就是一个 objc_object * 的结构体指针 12/// A pointer to an instance of a class.typedef struct objc_object *id; 在结构体内部只有一个 Class 结构的 isa isa 是什么？isa 的本质是 isa_t，在另外一个文件 objc-private.h 中有 isa_t 的定义，是一个联合体，也叫共用体，可以参考这篇文章讲解共用体。 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 这个里面存储两个，Class cls 和 uintptr_t bits。因为是联合体，所有实际只能有一个出现，ISA_BITFIELD是真正存储值的东西，它存储于文件 isa.h，根据平台不同而不同，下面是 arm64 版本的： ISA_BITFIELD 1234567891011121314151617# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD\\ uintptr_t nonpointer : 1; /*0：代表普通指针，1：表示优化过的，可以存储更多信息。*/\\ uintptr_t has_assoc : 1; /*是否设置过关联对象。如果没设置过，释放会更快*/\\ uintptr_t has_cxx_dtor : 1; /*是否有C++的析构函数*/\\ uintptr_t shiftcls : 33; /* MACH_VM_MAX_ADDRESS 0x1000000000 内存地址值*/ \\ uintptr_t magic : 6; /*用于在调试时分辨对象是否未完成初始化*/\\ uintptr_t weakly_referenced : 1; /*是否有被弱引用指向过*/\\ uintptr_t deallocating : 1; /*是否正在释放*/\\ uintptr_t has_sidetable_rc : 1; /*引用计数器是否过大无法存储在ISA中。如果为1，那么引用计数会存储在一个叫做SideTable的类的属性中*/\\ uintptr_t extra_rc : 19; /*里面存储的值是引用计数器减1*/\\# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) 这个 ISA_MASK 这种的就是一个蒙版，isa 完整的值通过跟他进行与操作，就只留下了class的地址，(Class)(isa.bits &amp; ISA_MASK) 话外一提，objc_object 的结构除了上面这个结构，根据这个结构存的值，提供了一整套的API方法，存储于 objc_private.h 文件中。 那么 Class 是什么呢？看2.0 2. class 结构体：objc_classClass 是 objc_class * 结构体指针。 objc_class 123456789struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() const &#123; return bits.data(); &#125;&#125; 这里先后存储的东西分四个： 继承来的 isa 结构的指针，占8字节 superClass 的 Class 指针，占8字节 cache类型，本篇跳过。 class_data_bits_t类型的bits，下段落展开。 3. 类中数据 class_data_bits_tclass_data_bits_t 里存储着当前类的很多信息，通过 class_data_bits_t 进行蒙版运算 (bits &amp; FAST_DATA_MASK) 可以算出 class_rw_t，简称就是 rw。下一段落重点讲解 class_rw_t。 ro rwe 另开篇幅重点讲解。 class_data_bits_t 12345678910111213141516171819202122232425262728293031323334struct class_data_bits_t &#123; friend objc_class; // Values are the FAST_ flags above. uintptr_t bits;public: class_rw_t* data() const &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125; void setData(class_rw_t *newData) &#123; ASSERT(!data() || (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE))); //这个过程不需要加锁处理，因为仅在实现或构造期间进行 Set 操作 //使用 store-release fence 操作，类似一种轻量级的资源锁， //如下面的`atomic_thread_fence `，因为可能会同时存在数据的读写 uintptr_t newBits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData; atomic_thread_fence(memory_order_release); bits = newBits; &#125;//获取类的ro数据，即使在构建过程中。//这个需要修复，至少在没有编译器屏障的情况下，并不是真正安全的。//在 实现类 更改数据字段的时候，可能没有内存屏障的。 const class_ro_t *safe_ro() &#123; class_rw_t *maybe_rw = data(); if (maybe_rw-&gt;flags &amp; RW_REALIZED) &#123; // maybe_rw is rw return maybe_rw-&gt;ro(); &#125; else &#123; // maybe_rw is actually ro return (class_ro_t *)maybe_rw; &#125; &#125;&#125; 上面代码提到了内存屏障，那么什么是内存屏障，这个概念涉及到代码的乱序执行，具体见文章「内存屏障，又是一个文章的强行占位符😬」 ro rw rwe 是相互依存的表述类结构的结构，ro 是在内存中直接读取出来的，只读readonly的，其中包括了我们熟悉的ivar，所以说ivar是不可以动态添加的，就是这个原因。 3.1 类数据演变出：class_ro_tclass_ro_t 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; _objc_swiftMetadataInitializer swiftMetadataInitializer() const &#123; if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123; return _swiftMetadataInitializer_NEVER_USE[0]; &#125; else &#123; return nil; &#125; &#125; method_list_t *baseMethods() const &#123; return baseMethodList; &#125; class_ro_t *duplicate() const &#123; if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123; size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]); class_ro_t *ro = (class_ro_t *)memdup(this, size); ro-&gt;_swiftMetadataInitializer_NEVER_USE[0] = this-&gt;_swiftMetadataInitializer_NEVER_USE[0]; return ro; &#125; else &#123; size_t size = sizeof(*this); class_ro_t *ro = (class_ro_t *)memdup(this, size); return ro; &#125; &#125;&#125;; 其中包含 const ivar_list_t * ivars 用来表示 ivar_list_t 和 ivar_t。 3.1.1ivar_list_t 和 ivar_tivar_list_t 通过 entsize_list_tt 存储了 ivar_t。 entsize_list_tt 是提供遍历器的通用容器，详细见我博客的另一篇文章，Apple源码用到的一些数据结构。 ivar_list_t 12345struct ivar_list_t : entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; &#123; bool containsIvar(Ivar ivar) const &#123; return (ivar &gt;= (Ivar)&amp;*begin() &amp;&amp; ivar &lt; (Ivar)&amp;*end()); &#125;&#125;; ivar_t 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; 3.2 类数据演变出：class_rw_trw 是可读可写的意思，runtime 动态增加方法等就是通过对 rw 进行修改写的操作完成的。 这里先看他的结构定义，对全局有了解。这里后续章节「。。。」详细展开更细致的研究。 class_rw_t 1234567891011121314struct class_rw_t &#123; uint32_t flags; uint16_t witness;#if SUPPORT_INDEXED_ISA uint16_t index;#endif Class firstSubclass; Class nextSiblingClass;public: class_rw_ext_t *deepCopy(const class_ro_t *ro); const method_array_t methods(); const property_array_t properties(); const protocol_array_t protocols();&#125;; 3.3 类数据演变出：class_rw_ext_t具体三者关系这里先不赘述。 class_rw_ext_t 12345678struct class_rw_ext_t &#123; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; char *demangledName; uint32_t version;&#125;; 4. method_array_t、 method_list_t、 method_t接下来三部分是： 类的 rw rwe 中的 method_array_t 类的 rw rwe 中的 property_array_t 类的 rw rwe 中的 protocol_array_t 这三个的继承数据结构都是：list_array_tt，详情可见我博客的另一篇文章，Apple源码用到的一些数据结构。 通过 rw rwe 中的 method_array_t 获取 methods，它的类型定义如下： method_array_t 12345678910111213141516171819class method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; &#123; typedef list_array_tt&lt;method_t, method_list_t&gt; Super; public: method_array_t() : Super() &#123; &#125; method_array_t(method_list_t *l) : Super(l) &#123; &#125; method_list_t * const *beginCategoryMethodLists() const &#123; return beginLists(); &#125; method_list_t * const *endCategoryMethodLists(Class cls) const; method_array_t duplicate() &#123; return Super::duplicate&lt;method_array_t&gt;(); &#125;&#125;; 其中获取到的一个或多个 method_list_t，具体原理移步到上面文章中。 method_list_t 12345678910111213// entsize 中的2个字符位用来做 fixup 标记。struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, 0x3&gt; &#123; bool isUniqued() const; bool isFixedUp() const; void setFixedUp(); uint32_t indexOfMethod(const method_t *meth) const &#123; uint32_t i = (uint32_t)(((uintptr_t)meth - (uintptr_t)this) / entsize()); ASSERT(i &lt; count); return i; &#125;&#125;; 通过遍历器遍历 method_t method_t 就是表示一个方法或者函数（包含：函数名、返回值、参数、函数体） method_t 1234567891011121314struct method_t &#123; SEL name; // 方法名称 const char *types; // 编码（返回值类型、参数类型） MethodListIMP imp; // 方法的地址/实现 struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; SortBySELAddress()方法是方便函数进行排序，其实在 methodList中 函数是根据SEL name这个对象的内存地址进行排序的，后续寻找方法的时候，会用二分查找增加查找效率。 4.1 method_t 方法的数据结构SEL是一个指向objc_selector 结构体的指针：typedef struct objc_selector *SEL; 获取一个SEL的方法 1234567SEL sel1 &#x3D; @selector(selector);SEL sel2 &#x3D; sel_registerName(&quot;selector&quot;);SEL sel3 &#x3D; NSSelectorFromString(@&quot;selector&quot;);&#x2F;&#x2F; SEL 转换成字符串char *string1 &#x3D; sel_getName(sel1);NSString *string2 &#x3D; NSStringFromSelector(sel1); IMP 是指向方法实现提的函数指针，调用一个方法，本质上就是一个方法寻址的过程，通过SEL寻找IMP。method_t，就是在两者之间做映射关系 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void &#x2F;* id, SEL, ... *&#x2F; ); #elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); #endif 4.2 Type EncodingsType Encodings 就是一个编码，runtime 中对于 method_t 的返回值和参数，使用了Type Encodings 字符串来进行描述：@encode()指令可以将类型转换为 Type Encodings 字符串编码： 123char *buf1 = @encode(int **);char *buf2 = @encode(struct key);char *buf3 = @encode(Rectangle); OC 方法都有两个隐式参数，方法调用者 (id)self 和方法名 (SEL) _cmd ，所以我们才能在方法中使用 self 和 _cmd ； 如 -(void)test，它的编码为 “v16@0:8”，可以简写为 “v@:”v：代表返回值类型为 void16：代表所有参数所占的总字节数@：代表参数 1 类型为 id0：代表参数 1 从第几个字节开始存储:：代表参数 2 类型为 SEL8：代表参数 2 从第几个字节开始存储 具体这里在官网上有详细解释，See Type Encodings in Objective-C Runtime Programming Guide。 5. property_array_t、 property_list_t、 property_tproperty_array_t 12345678910111213class property_array_t : public list_array_tt&lt;property_t, property_list_t&gt; &#123; typedef list_array_tt&lt;property_t, property_list_t&gt; Super; public: property_array_t() : Super() &#123; &#125; property_array_t(property_list_t *l) : Super(l) &#123; &#125; property_array_t duplicate() &#123; return Super::duplicate&lt;property_array_t&gt;(); &#125;&#125;; property_list_t 12struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; &#123;&#125;; property_t 1234struct property_t &#123; const char *name; const char *attributes;&#125;; 6. protocol_array_t、 protocol_list_t、 protocol_tprotocol_array_t 1234567891011121314class protocol_array_t : public list_array_tt&lt;protocol_ref_t, protocol_list_t&gt; &#123; typedef list_array_tt&lt;protocol_ref_t, protocol_list_t&gt; Super; public: protocol_array_t() : Super() &#123; &#125; protocol_array_t(protocol_list_t *l) : Super(l) &#123; &#125; protocol_array_t duplicate() &#123; return Super::duplicate&lt;protocol_array_t&gt;(); &#125;&#125;; protocol_list_t 1234567891011121314151617181920212223242526272829struct protocol_list_t &#123; // count is pointer-sized by accident. uintptr_t count; protocol_ref_t list[0]; // variable-size size_t byteSize() const &#123; return sizeof(*this) + count*sizeof(list[0]); &#125; protocol_list_t *duplicate() const &#123; return (protocol_list_t *)memdup(this, this-&gt;byteSize()); &#125; typedef protocol_ref_t* iterator; typedef const protocol_ref_t* const_iterator; const_iterator begin() const &#123; return list; &#125; iterator begin() &#123; return list; &#125; const_iterator end() const &#123; return list + count; &#125; iterator end() &#123; return list + count; &#125;&#125;; protocol_t 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125; bool isFixedUp() const; void setFixedUp(); bool isCanonical() const; void clearIsCanonical();# define HAS_FIELD(f) (size &gt;= offsetof(protocol_t, f) + sizeof(f)) bool hasExtendedMethodTypesField() const &#123; return HAS_FIELD(_extendedMethodTypes); &#125; bool hasDemangledNameField() const &#123; return HAS_FIELD(_demangledName); &#125; bool hasClassPropertiesField() const &#123; return HAS_FIELD(_classProperties); &#125;# undef HAS_FIELD const char **extendedMethodTypes() const &#123; return hasExtendedMethodTypesField() ? _extendedMethodTypes : nil; &#125; property_list_t *classProperties() const &#123; return hasClassPropertiesField() ? _classProperties : nil; &#125;&#125;; 6.isa 走位图这个图解释网上太多了，没什么好说的，放这里，跳过不讲了。 拓展研究内存屏障 memory barrier上面源码中 class_ro_t *safe_ro() 的注释里提到了一个的 compiler barrier，编译器屏障，这个是为了解决代码执行问题的。 指令重排是指：导致的代码乱序执行。举例来说：如果第一个语句涉及内存读取，第二个语句只是简单的指令计算，那么CPU为了提高效率，完全可能在第一个语句的内存读取完成之前，先执行完了第二个语句。 上下两条指令没有相关性，就可能发生。如果涉及一个值，就有可能发现。另外一个概念叫做 as if serial，重排序的原则是看上去像是顺序执行的，不影响单线程的最终一致性。 但是多线程是不保证一致性的。所以重排序是CPU的公共特性。 然后就出现了，内存屏障 memory barrier屏障上下的指令不会发生重排序，在汇编层面，通过 lock 汇编指令完成，lock是锁总线，CPU访问内存的总线，等指令访问完了，其他CPU才能去访问。 lock 本身的前面的所有指令全部不能越过 lock 重排序。 拓展阅读：Linux内核同步机制之（三）：memory barrier References objc4_781 官方源码 简图记录-android fence机制 Fence和非原子操作的ordering C语言共用体（C语言union用法）详解。 补充git上找到的一个 o_t c_t ro rw rwe 连通图，名字我自己瞎起的，我后面画图会参考这个","categories":[],"tags":[]}],"categories":[],"tags":[]}